generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  friendsA           Friend[]        @relation("friend_a")
  friendsB           Friend[]        @relation("friend_b")
  friendRequestsFrom FriendRequest[] @relation("friendrequest_from")
  friendRequestsTo   FriendRequest[] @relation("friendrequest_to")
  status             StatusType?     @default(OFFLINE)
  Message            Message[]
  createdChatRoom    Chat[]          @relation("owner")
  chat               Chat[]          @relation("RoomUser")
  voiceRoom          VoiceRoom[]     @relation("VoiceRoomUser")
  createdBy          VoiceRoom[]     @relation("owner")
  MessageStatus      MessageStatus[]
}

model Chat {
  id    String  @id @default(uuid())
  name  String
  about String?

  createdBy   User?     @relation("owner", fields: [createdById], references: [id], onDelete: Cascade)
  createdById String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt()
  keyPair     KeyPair?
  users       User[]    @relation("RoomUser")
  messages    Message[]
}

model Message {
  id       String  @id @default(uuid())
  text     String
  imageUrl String?

  createdAt     DateTime        @default(now())
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  chat          Chat            @relation(fields: [chatId], references: [id], onDelete: Cascade)
  chatId        String
  MessageStatus MessageStatus[]
}

model MessageStatus {
  id        String            @id @default(uuid())
  messageId String
  userId    String
  status    MessageStatusType
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt()
  message   Message           @relation(fields: [messageId], references: [id])

  user User @relation(fields: [userId], references: [id])
}

model KeyPair {
  id         String @id @default(cuid())
  publicKey  String
  privateKey String
  chat       Chat   @relation(fields: [chatId], references: [id])
  chatId     String @unique
}

model FriendRequest {
  id        String   @id @default(uuid())
  fromId    String
  toId      String
  createdAt DateTime @default(now())
  from      User     @relation("friendrequest_from", fields: [fromId], references: [id], onDelete: Cascade)
  to        User     @relation("friendrequest_to", fields: [toId], references: [id], onDelete: Cascade)

  @@unique([fromId, toId])
  @@index([toId])
}

model Friend {
  id        String   @id @default(uuid())
  aId       String
  bId       String
  createdAt DateTime @default(now())
  a         User     @relation("friend_a", fields: [aId], references: [id], onDelete: Cascade)
  b         User     @relation("friend_b", fields: [bId], references: [id], onDelete: Cascade)

  @@unique([aId, bId])
  @@index([bId])
}

model VoiceRoom {
  id          String    @id @default(uuid())
  name        String
  about       String?
  liveAt      DateTime?
  roomType    RoomType? @default(PUBLIC)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt()
  createdBy   User?     @relation("owner", fields: [createdById], references: [id], onDelete: Cascade)
  createdById String?
  users       User[]    @relation("VoiceRoomUser")
}

enum StatusType {
  ONLINE
  OFFLINE
}

enum RoomType {
  PUBLIC
  PRIVATE
}

enum MessageStatusType {
  READ
  UNREAD
}
